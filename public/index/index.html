<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Blog">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title> The .NET Developer&#x27;s Guide to Rust </title>
    <link rel="apple-touch-icon" sizes="57x57" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;apple-icon-180x180.png">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="192x192"  href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="description" itemprop="about" content="">
    <meta name="keywords" itemprop="keywords" content="[Rust, C#]">
    <meta itemprop="headline" content=""/>
    
    <meta property="og:title" content=" The .NET Developer&#x27;s Guide to Rust ">
    <meta property="og:description" content=" Or How to Get There From Here ">
    <meta property="og:image" content="og_image.png">
    <meta property="og:url" content="http:&#x2F;&#x2F;www.rust4sharp.com&#x2F;index&#x2F;">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:site_name" content="Rust 4 C# Developers">
    <meta name="twitter:image:alt" content="The .NET Developer&#x27;s Guide to Rust">

    
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600|Source+Code+Pro">
    <link rel="stylesheet" href="/site.css">
</head>

<body>
    <div 
     itemscope itemtype="http://schema.org/Organization">
    </div>

    <header class="header">
        <div class="container">
            <a class="title" href="http:&#x2F;&#x2F;www.rust4sharp.com">
                    <img src="og_image.png" alt="">
                    <h1 >Rust 4 C# Developers</h1>
            </a>
        </div>
    </header>

    <div class="container padding-header">
        
<article itemscope itemtype="http://schema.org/BlogPosting" class="post post-page">
    
    
    <meta itemprop="image" content="og_image.png">
    
    
    <header>
        
        <h1 class="title" itemprop="headline">The .NET Developer&#x27;s Guide to Rust</h1>
        <address itemprop="author" itemscope itemtype="https://schema.org/Person">
            <span itemprop="name">by The Sharp Ninja</span>
        </address>
        <div class="extra">
            

            
            <aside class="sidebar">
                <h3>Rust Resources</h3>
                <ul class="base-list">
                    <li>
                        <a href="https:&#x2F;&#x2F;www.rust-lang.org&#x2F;" target="_blank">Rust Language</a>
                    </li>
                    
                    <li>
                        <a href="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;" target="_blank">Rust Playground</a>
                    </li>
                    
                    <li>
                        <a href="https:&#x2F;&#x2F;discord.gg&#x2F;aVESxV8" target="_blank">Rust on Discord</a>
                    </li>
                    
                    <li>
                        <a href="https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;rust&#x2F;" target="_blank">Rust on Reddit</a>
                    </li>
                    
                    <li>
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;kud1ing&#x2F;awesome-rust" target="_blank">Awesome Rust</a>
                    </li>
                    
                </ul>
                <h3>Social Media</h3>
                <ul class="base-list">
                    <li>
                        <a href="https:&#x2F;&#x2F;medium.com&#x2F;the-unpopular-opinions-of-a-senior-developer" target="_blank">Medium</a>
                    </li>
                    
                    <li>
                        <a href="https:&#x2F;&#x2F;github.com&#x2F;gatewayprogrammingschool&#x2F;Rust-For-CSharp-Developers" target="_blank">Github</a>
                    </li>
                    
                </ul>
            </aside>
            
        </div>
    </header>
    <div itemprop="articleBody" class="body">
        <h2 id="get-ready">Get Ready!</h2>
<p>C# has curly braces and owes its origins to C.  Rust also has curly braces and owes its origins to C.  There are even some shared keywords such <code>struct</code>, <code>for</code> and <code>while</code>.</p>
<p><em>And that’s where the similarities end.</em></p>
<p>You must clear your mind now and be prepared to reorient for Rust.  This doesn’t mean that Rust will be totally alien and make you rethink your life as a C# developer.  <em>Well, maybe it does.</em></p>
<h2 id="the-journey-begins">The Journey Begins</h2>
<p>I have been wanting to learn Rust for quite a while now.  I’ve jealously eyed how <a rel="noopener" target="_blank" href="https://1drv.ms/x/s!At7D0T4Uz1vyjM8AlDMCWKyIYS1cOQ?e=Lv5fnM">Rust often overtakes C++ in performance</a> while C# lags behind the “fast three (C/C++/Rust)” in benchmarks.  Every time C# gets faster, so does Rust.  It’s not fair!</p>
<p>So I’m learning Rust.  I’m doing <a rel="noopener" target="_blank" href="https://www.udemy.com/share/101Z1IAEETdF9SQXUD/">“The Rust Programming Language” on Udemy</a>.  It’s a great course that is very thorough and moves quickly enough to keep your interest.  It does not assume you have any experience in a specific language, but does assume you are a programmer already and that you understand the purpose of each element that is being presented to you.</p>
<p>This article is going to focus on the differences between C# and Rust as I understand them from doing the course and working with some code on my own.</p>
<h2 id="the-community">The Community</h2>
<p>First, I want to point out that the people in the Rust community have been fantastic to me so far.  No question has been left unanswered and no snarky answers or comments have come my way.  This is amazing to me for a very specific reason.  Rust is a big-brain language.  I can see where being effective with it and coding efficiently with it requires planning and consideration of the long term ramifications of every decision you make.  You honestly get the sense that Rust’s followers are in it for the right reasons: they want people to write <em>safe</em>, <em>secure</em> and <em>well performing</em> code, no matter what.  This has been consistent whether you are on the official Rust forums, Reddit or Discord.</p>
<h2 id="getting-set-up">Getting Set Up</h2>
<p>This is probably the topic that draws the most disagreement among Rustaceans.  Half of them like to use Visual Studio Code + Rust Analyzer.  The other half like Jet Brains IDEs (Usually CLion) + the Rust Extension.  I went with CLion (by Jet Brains) with the Rust Extension.  If you have used Rider then this is a no brainer, the UI and Debugging tools are nearly identical, and I’m already fluent in Rider.  If you have a preference for either debugger than stick with that because the debugger will ultimately light up the bulbs for you more than any tutorial.</p>
<p>There’s also a Visual Studio 2019 Extension for Rust.  I haven’t used it yet, mainly because the speaker in the Video Series uses it (alternating with IntelliJ) about half the time and the extension as presented in the videos is very incomplete with poor hover text and error messages that are incomplete.  Rust, more than any other language, gives you very explicit and useful error messages, and their community takes great pride in that.  C# devs are accustomed to having the best tooling and documentation.  Although Rust lacks a dedicated IDE, the tooling with Jet Brains IDEs and Visual Studio Code are top-notch, and Rust’s documentation rivals Microsoft’s documentation for .NET Framework (we all know the docs for Dotnet Core have taken a step backwards from the days of physical MSDN Library Discs).</p>
<h2 id="ecosystem">Ecosystem</h2>
<p>Beyond tooling, the availability and visibility of frameworks makes a huge difference in the day-to-day life of a developer.  C# developers currently revel in what is hands-down the best ecosystem to work in.  20 years of quality and maturity is hard to compete with when you are both new and fundamentally different.  Rust has some very impressive elements in its ecosystem, too.  <a rel="noopener" target="_blank" href="https://actix.rs/">Actix Web</a> is one of the <a rel="noopener" target="_blank" href="https://www.techempower.com/benchmarks/">fastest web frameworks anywhere</a>, rivaling <a rel="noopener" target="_blank" href="https://github.com/an-tao/drogon">C++’s Drogon</a> in raw performance on benchmarks.  <a rel="noopener" target="_blank" href="https://github.com/yewstack/yew">Yew</a> is the most mature WASM library for creating Web clients, but interestingly the <a rel="noopener" target="_blank" href="https://users.rust-lang.org/t/old-programmer-thats-new-to-rust/54739/11?u=sharpninja">Rustaceans have been warning me</a> to wait and not use it for a production project and to use TypeScript instead.  This, of course, blows my mind as a C# dev as I see ANY functioning WASM library as an escape from JavaScript crap frameworks.</p>
<p>The last major area of the ecosystem I’ve looked into is ORMs and it seems to me that <a rel="noopener" target="_blank" href="https://diesel.rs/">Diesel</a> is the most complete.  It fits in somewhere between EF Core and Dapper.  It’s ORM features far surpass those of Dapper, but it’s migration tools require more manual SQL DDL than EF Core requires.  The documentation for Diesel warns of ensuring that your DDL exactly matches your entities or queries will blow up.  Frankly, full round trip engineering for DDL has been a normal feature of ORM systems since the mid 2000’s, including Entity Framework.</p>
<h2 id="language-paradigms">Language Paradigms</h2>
<p>C# is first and foremost an Object Oriented Programming Language in the mold of C++.  In C#, everything is an object of some kind, even simple types such as <code>int</code> or <code>decimal</code>.  The explanation for this is that <em>everything</em> in C# is a <strong>closure</strong>.  Of course, as you add members to objects you are adding layers of closures with scoping and accessibility modifiers that determine visibility on each member.  The difference between a <code>struct</code> and a <code>class</code> is only a matter of how the compiler treats memory access to the root closure that is created with the <code>struct </code>being treated as a Value type and the <code>class</code> being treated as a Reference type.  In C# we have a Garbage Collector that keeps track of what variables point to a Reference-type closure.  When that count reaches zero, then the closure is marked for deletion.  For value types, there is only one reference at all time.  When that reference falls out of scope, the value is destroyed.  Every time you use a value type, it is copied on the stack and that copy is referenced.</p>
<p>Rust is very different.  Rust introduces the concepts of Ownership, Borrowing and Timeline.  Only one variable can own a value in Rust, regardless of what it is.  The value can be Borrowed by other scopes, but ownership remains with a single variable.  When a variable that Owns data falls out of scope, it’s Timeline ends and the data is destroyed.  If there were borrowed references to this destroyed data then they would become invalid.  But Rust doesn’t let that happen.  The compiler tracks all borrowed references and if there are outstanding borrowed references when the owner falls out of scope, then the compiler throws a very descriptive error.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">main() {</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// Declare a mutable vector</span><span style="color:#dcdcdc;">
    </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> vec = </span><span style="color:#569cd6;">&amp;mut </span><span style="color:#dcdcdc;">vec![</span><span style="color:#569cd6;">&amp;</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">,</span><span style="color:#569cd6;">&amp;</span><span style="color:#b5cea8;">2</span><span style="color:#dcdcdc;">,</span><span style="color:#569cd6;">&amp;</span><span style="color:#b5cea8;">3</span><span style="color:#dcdcdc;">];</span><span style="color:#dcdcdc;">
	</span><span style="color:#608b4e;">// vec is the owner</span><span style="color:#dcdcdc;">
    </span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// pass it to a function</span><span style="color:#dcdcdc;">
    do_something(vec);</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// display the result</span><span style="color:#dcdcdc;">
    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, vec);</span><span style="color:#dcdcdc;">
}</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
</span><span style="color:#608b4e;">// Function to accept mutable vector</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">pub fn </span><span style="color:#dcdcdc;">do_something(vec: </span><span style="color:#569cd6;">&amp;mut </span><span style="color:#dcdcdc;">Vec&lt;</span><span style="color:#569cd6;">&amp;u32</span><span style="color:#dcdcdc;">&gt;)</span><span style="color:#dcdcdc;">
{</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// vec is borrowing the Vector</span><span style="color:#dcdcdc;">
    </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> a = </span><span style="color:#b5cea8;">100</span><span style="color:#dcdcdc;">;</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// a owns 100</span><span style="color:#dcdcdc;">
    </span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// Add another value to the vector</span><span style="color:#dcdcdc;">
    vec.push(</span><span style="color:#569cd6;">&amp;</span><span style="color:#dcdcdc;">a);</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// a is now borrowed by vec</span><span style="color:#dcdcdc;">
}</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>This code will not compile because <code>a</code> in <code>do_something</code> owns the value placed in the vector and when <code>do_something</code> falls out of scope the value will be destroyed.  However, that would leave the vector with invalid data and so the compiler refuses to do this.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#dcdcdc;">error[</span><span style="color:#b4cea8;">E0597</span><span style="color:#dcdcdc;">]: `a` does not live long enough</span><span style="color:#dcdcdc;">
  --&gt; src/main.rs:</span><span style="color:#b5cea8;">14</span><span style="color:#dcdcdc;">:</span><span style="color:#b5cea8;">14</span><span style="color:#dcdcdc;">
   </span><span style="color:#569cd6;">|</span><span style="color:#dcdcdc;">
</span><span style="color:#b5cea8;">11 </span><span style="color:#569cd6;">| pub fn </span><span style="color:#dcdcdc;">do_something(vec: </span><span style="color:#569cd6;">&amp;mut </span><span style="color:#dcdcdc;">Vec&lt;</span><span style="color:#569cd6;">&amp;u32</span><span style="color:#dcdcdc;">&gt;)</span><span style="color:#dcdcdc;">
   </span><span style="color:#569cd6;">|                                   </span><span style="color:#dcdcdc;">- </span><span style="color:#569cd6;">let&#39;s</span><span style="color:#dcdcdc;"> call the lifetime of this reference `</span><span style="color:#569cd6;">&#39;</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">`</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">...</span><span style="color:#dcdcdc;">
</span><span style="color:#b5cea8;">14 </span><span style="color:#569cd6;">|</span><span style="color:#dcdcdc;">     vec.push(</span><span style="color:#569cd6;">&amp;</span><span style="color:#dcdcdc;">a);</span><span style="color:#dcdcdc;">
   |     ---------^^-</span><span style="color:#dcdcdc;">
   </span><span style="color:#569cd6;">|     |        |</span><span style="color:#dcdcdc;">
   </span><span style="color:#569cd6;">|     |</span><span style="color:#dcdcdc;">        borrowed value does not live long enough</span><span style="color:#dcdcdc;">
   </span><span style="color:#569cd6;">|</span><span style="color:#dcdcdc;">     argument requires that `a` is borrowed </span><span style="color:#569cd6;">for</span><span style="color:#dcdcdc;"> `</span><span style="color:#569cd6;">&#39;</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">`</span><span style="color:#dcdcdc;">
</span><span style="color:#b5cea8;">15 </span><span style="color:#569cd6;">|</span><span style="color:#dcdcdc;"> }</span><span style="color:#dcdcdc;">
   </span><span style="color:#569cd6;">| </span><span style="color:#dcdcdc;">- `a` dropped here </span><span style="color:#569cd6;">while</span><span style="color:#dcdcdc;"> still borrowed</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>This does two things:</p>
<ol>
<li>No garbage collector is necessary because all memory is destroyed when its owner falls out of scope.</li>
<li>It is impossible to have a pointer to invalid data, or a pointer that references invalid memory.</li>
</ol>
<p>So with Rust, we eliminate the biggest security flaw with C/C++ and the biggest performance penalty of C#.  AND, we get incredibly useful error messages as well.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">pub fn </span><span style="color:#dcdcdc;">do_something(vec: </span><span style="color:#569cd6;">&amp;mut </span><span style="color:#dcdcdc;">Vec&lt;</span><span style="color:#569cd6;">&amp;u32</span><span style="color:#dcdcdc;">&gt;)</span><span style="color:#dcdcdc;">
{</span><span style="color:#dcdcdc;">
    vec.push(</span><span style="color:#569cd6;">&amp;</span><span style="color:#b5cea8;">100</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
    </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> a = vec[vec.len()-</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">];</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
    println!(</span><span style="color:#d69d85;">&quot;a: </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, a);</span><span style="color:#dcdcdc;">
}</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>By changing things around, we make <code>vec</code> the owner of the new value and borrow it locally, thus giving us our expected result.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#dcdcdc;">a: </span><span style="color:#b5cea8;">100</span><span style="color:#dcdcdc;">
[</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">2</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">3</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">100</span><span style="color:#dcdcdc;">]</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
Process finished with exit code </span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">
</span></code></pre>
<ul>
<li><a rel="noopener" target="_blank" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=6b59d6bee45f621a77ed7ea01bce3bfe">Invalid Code</a> in Rust Playground</li>
<li><a rel="noopener" target="_blank" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=89e7027f1040904f9ca75d6305084d63">Working Code</a> in Rust Playground</li>
</ul>
<h2 id="types">Types</h2>
<h3 id="numbers">Numbers</h3>
<p>Rust and C# support the same basic numeric types (with one exception).</p>
<table><thead><tr><th>Type</th><th>Rust</th><th>C#</th></tr></thead><tbody>
<tr><td>Boolean</td><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td>8-bit byte</td><td><code>u8</code></td><td><code>byte</code></td></tr>
<tr><td>Signed 8-bit byte</td><td><code>i8</code></td><td><code>sbyte</code></td></tr>
<tr><td>16-bit word</td><td><code>i16</code></td><td><code>short</code></td></tr>
<tr><td>Unsigned 16-bit word</td><td><code>u16</code></td><td><code>ushort</code></td></tr>
<tr><td>32-bit double-word</td><td><code>i32</code></td><td><code>int</code></td></tr>
<tr><td>Unsigned 32-bit double word</td><td><code>u32</code></td><td><code>uint</code></td></tr>
<tr><td>64-bit long-word</td><td><code>i64</code></td><td><code>long</code></td></tr>
<tr><td>Unsigned 64-bit long-word</td><td><code>u64</code></td><td><code>ulong</code></td></tr>
<tr><td>Native Integer</td><td><code>isize</code></td><td><code>nint</code></td></tr>
<tr><td>Unsigned Native Integer</td><td><code>usize</code></td><td><code>nuint</code></td></tr>
<tr><td>Single-Precision Floating Point 32-bit</td><td><code>f32</code></td><td><code>float</code></td></tr>
<tr><td>Double-Precision Floating Point 64-bit</td><td><code>f64</code></td><td><code>double</code></td></tr>
</tbody></table>
<p>You’ll notice that <code>decimal</code> is not listed.  Rust does not currently include a lossless decimal type.  There are crates (the equivalent of NuGet packages) that provide this functionality, but until one becomes part of the language you should be very careful about handling money in Rust code.</p>
<h3 id="strings">Strings</h3>
<p><code>Strings </code>are something that .NET Framework nailed on day 1.  Since the beginning of C#, <code>Strings</code> have been internally represented as full Unicode character arrays that are immutable.  The <code>StringBuilder </code>class has always been around for doing proper string manipulation from the beginning.  Strings in C# are always a reference type, meaning you never get direct access to it, all you can do is request a copy of it or feed the reference to something else.  Operations on strings in C# always result in a new <code>string</code> (except when using <code>StringBuilder</code>).</p>
<p>In Rust, there are <strong>two</strong> string types.  The first, declared as <code>&amp;str</code> is very much like a .NET Framework <code>string</code>.  String literals are always of this type.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> my_string = </span><span style="color:#d69d85;">&quot;My String&quot;</span><span style="color:#dcdcdc;">;</span><span style="color:#dcdcdc;">
</span><span style="color:#608b4e;">// my_string has type of &amp;str	</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>One major difference is that internally, Rust represent strings with UTF-8 instead of straight Unicode.  This means that strings are more memory efficient in Rust at the expense of higher overhead for interpreting individual characters.  Whereas you can calculate a character in a C# string from an offset into the string’s memory, with Rust you must first tokenize the byte array to a char array.</p>
<p>The second type is <code>String</code>, which actually behaves like the C# <code>StringBuilder</code> class.  If you are assembling strings on the fly you use this type.  One major difference between C# and Rust is that the output of <code>ToString()</code> and <code>to_string()</code> are opposites.  The .NET <code>ToString()</code> method on all objects returns an immutable <code>string</code>.  The <code>to_string()</code> method found on many Rust objects returns <code>String</code>, not the immutable <code>&amp;str</code>.  As a matter of fact, you can get a <code>String</code> from a <code>&amp;str</code> in two ways.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> s = </span><span style="color:#d69d85;">&quot;Template {{0}}&quot;</span><span style="color:#dcdcdc;">.to_string();</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> s = String::new(</span><span style="color:#d69d85;">&quot;Template {{0}}&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
</span></code></pre><h3 id="string-formatting">String Formatting</h3>
<p>One of the best feature of .NET is string formatting and string interpolation.  C# has always rich support for formatting strings using the <code>string.Format</code> method and passing formatters to the <code>ToString</code> method of numeric types.  Now, interpolated strings allow using formatted string anywhere that accepts a string.</p>
<p>Things are a little different in Rust.  Instead of using a simple method of the <code>String</code> object to format strings, you use a system supplied macro called <code>format!</code> which outputs a <code>&amp;str</code>.  The syntax is familiar, though.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> name = </span><span style="color:#d69d85;">&quot;The Sharp Ninja&quot;</span><span style="color:#dcdcdc;">;</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> s = format!(</span><span style="color:#d69d85;">&quot;My name is </span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">.&quot;</span><span style="color:#dcdcdc;">, name);</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>The variable <code>s</code> is an immutable <code>&amp;str</code> containing <code>My name is The Sharp Ninja.</code></p>
<p>Writing to the console is similarly performed with a macro named <code>println!</code></p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// Output values multiple times</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;My name is </span><span style="color:#b4cea8;">{name}</span><span style="color:#d69d85;">, but you can call me </span><span style="color:#b4cea8;">{name}</span><span style="color:#d69d85;">.&quot;</span><span style="color:#dcdcdc;">, name);</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
</span><span style="color:#608b4e;">// Pretty Pring a Range</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;Range: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, (</span><span style="color:#b5cea8;">1</span><span style="color:#569cd6;">..</span><span style="color:#b5cea8;">11</span><span style="color:#dcdcdc;">).collect::&lt;Vec&lt;</span><span style="color:#569cd6;">_</span><span style="color:#dcdcdc;">&gt;&gt;());</span><span style="color:#dcdcdc;">
</span></code></pre>
<blockquote>
<p>Note: The formatting macros always require a format string followed by any values to place in the format string.  So <code>println!(s)</code> is not valid, but <code>println!(&quot;{}&quot;, s)</code> is.</p>
</blockquote>
<h2 id="collections">Collections</h2>
<p><code>Vector</code> is the primary collection used in Rust.  Vectors are strongly typed and Rust’s strong type system is normally used to define the type of a <code>Vector's</code> contents.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// Create a vector of &amp;str values</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> v = vec!(</span><span style="color:#d69d85;">&quot;ABC&quot;</span><span style="color:#dcdcdc;">, </span><span style="color:#d69d85;">&quot;def&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:#?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
</span></code></pre><pre style="background-color:#1e1e1e;">
<code><span style="color:#dcdcdc;">OUTPUT: </span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
[</span><span style="color:#dcdcdc;">
    &quot;ABC&quot;,</span><span style="color:#dcdcdc;">
    &quot;def&quot;,</span><span style="color:#dcdcdc;">
]</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>Notice that I added the <code>mut</code> keyword to the vector’s declaration.  This means that the vector is mutable and thus more values can be added.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// Create a vector of &amp;str values</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> v = vec!(</span><span style="color:#d69d85;">&quot;ABC&quot;</span><span style="color:#dcdcdc;">, </span><span style="color:#d69d85;">&quot;def&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
v.push(</span><span style="color:#d69d85;">&quot;HIJK&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
v.push(</span><span style="color:#d69d85;">&quot;lmno&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
v.push(</span><span style="color:#d69d85;">&quot;P&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>Yields</p>
<pre style="background-color:#1e1e1e;">
<code><span style="color:#dcdcdc;">[&quot;ABC&quot;, &quot;def&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;, &quot;P&quot;]</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>The <code>Vector</code> acts like a stack as well.  Notice we place new items with <code>push</code>?  We can <code>pop</code> items from the vector as you would expect from a stack.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> v = vec!(</span><span style="color:#d69d85;">&quot;ABC&quot;</span><span style="color:#dcdcdc;">, </span><span style="color:#d69d85;">&quot;def&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
v.push(</span><span style="color:#d69d85;">&quot;HIJK&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
v.push(</span><span style="color:#d69d85;">&quot;lmno&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
v.push(</span><span style="color:#d69d85;">&quot;P&quot;</span><span style="color:#dcdcdc;">);</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v);</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> last = v.pop();</span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;"> - </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v, last);</span><span style="color:#dcdcdc;">
last = v.pop();    </span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;"> - </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v, last);</span><span style="color:#dcdcdc;">
last = v.pop();    </span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;"> - </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v, last);</span><span style="color:#dcdcdc;">
last = v.pop();    </span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;"> - </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v, last);</span><span style="color:#dcdcdc;">
last = v.pop();    </span><span style="color:#dcdcdc;">
println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;"> - </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, v, last);</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>Yields</p>
<pre style="background-color:#1e1e1e;">
<code><span style="color:#dcdcdc;">[&quot;ABC&quot;, &quot;def&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;, &quot;P&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;] - Some(&quot;P&quot;)</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;] - Some(&quot;lmno&quot;)</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;] - Some(&quot;HIJK&quot;)</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;] - Some(&quot;def&quot;)</span><span style="color:#dcdcdc;">
[] - Some(&quot;ABC&quot;)</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>Wait a minute!  What’s with the <code>Some(&quot;P&quot;)</code>?  That is one of the great features of Rust, <code>Option&lt;T&gt;</code>, which is baked into the entire language.  We haven’t talked about <code>null</code> handling so far because in Rust there is no <code>null</code>.  Quite simply, if you have a method where not returning a value is a valid option, then the return type of the method must be <code>Option&lt;T&gt;</code> and if there is no value to return, you return <code>None</code>, otherwise you return <code>Some&lt;T&gt;</code>.  What would happen if we <code>pop</code> one more time from an empty <code>Vector</code>?</p>
<pre style="background-color:#1e1e1e;">
<code><span style="color:#dcdcdc;">[&quot;ABC&quot;, &quot;def&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;, &quot;P&quot;]</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;, &quot;lmno&quot;] - Some(&quot;P&quot;)</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;, &quot;HIJK&quot;] - Some(&quot;lmno&quot;)</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;, &quot;def&quot;] - Some(&quot;HIJK&quot;)</span><span style="color:#dcdcdc;">
[&quot;ABC&quot;] - Some(&quot;def&quot;)</span><span style="color:#dcdcdc;">
[] - Some(&quot;ABC&quot;)</span><span style="color:#dcdcdc;">
[] - None</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>Now we don’t have to worry about <code>null</code> values causing error, or attempting to reference a null pointer.  It’s impossible.  Notice there’s no value type on <code>None</code> just for this reason.  We’ll talk more about <code>Option&lt;T&gt;</code> when we discussion program flow control.</p>
<h3 id="iterators">Iterators</h3>
<p>In .NET, all collections implement <code>IEnumerable</code>, even arrays.  <code>IEnumerable</code> is the basis for all iterating of collections via <code>foreach</code> and Linq.  Rust doesn’t have a direct analogous concept as <code>IEnumerable</code>, but there is something similar with <code>Iterator</code>.   Let’s look at an <code>Iterator</code> in action.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> values = vec![</span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">2</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">3</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">4</span><span style="color:#dcdcdc;">, </span><span style="color:#b5cea8;">5</span><span style="color:#dcdcdc;">];</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
</span><span style="color:#569cd6;">for</span><span style="color:#dcdcdc;"> x </span><span style="color:#569cd6;">in</span><span style="color:#dcdcdc;"> values {</span><span style="color:#dcdcdc;">
    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, x);</span><span style="color:#dcdcdc;">
}</span><span style="color:#dcdcdc;">
</span></code></pre>
<p><code>Values</code> is a <code>Vector</code>, which implements the trait <code>IntoIterator</code>.  What’s a trait?  Traits are like interfaces in C#.  They define contracts that objects must implement.  The difference is that traits are implemented independently of the object.  In C#, classes implementing <code>IEnumerable</code> must implement <code>GetEnumerator()</code> in their class.  In Rust, Traits are implemented on a separate <code>struct</code>.</p>
<pre style="background-color:#1e1e1e;">
<code class="language-rust" data-lang="rust"><span style="color:#569cd6;">impl </span><span style="color:#dcdcdc;">Iterator </span><span style="color:#569cd6;">for </span><span style="color:#dcdcdc;">Counter {</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// we will be counting with usize</span><span style="color:#dcdcdc;">
    </span><span style="color:#569cd6;">type </span><span style="color:#4ec9b0;">Item </span><span style="color:#dcdcdc;">= </span><span style="color:#569cd6;">usize</span><span style="color:#dcdcdc;">;</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
    </span><span style="color:#608b4e;">// next() is the only required method</span><span style="color:#dcdcdc;">
    </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">next(</span><span style="color:#569cd6;">&amp;mut </span><span style="color:#dcdcdc;">self) -&gt; Option&lt;</span><span style="color:#569cd6;">Self::</span><span style="color:#dcdcdc;">Item&gt; {</span><span style="color:#dcdcdc;">
        </span><span style="color:#608b4e;">// Increment our count. This is why we started at zero.</span><span style="color:#dcdcdc;">
        self.count += </span><span style="color:#b5cea8;">1</span><span style="color:#dcdcdc;">;</span><span style="color:#dcdcdc;">
</span><span style="color:#dcdcdc;">
        </span><span style="color:#608b4e;">// Check to see if we&#39;ve finished counting or not.</span><span style="color:#dcdcdc;">
        </span><span style="color:#569cd6;">if </span><span style="color:#dcdcdc;">self.count &lt; </span><span style="color:#b5cea8;">6 </span><span style="color:#dcdcdc;">{</span><span style="color:#dcdcdc;">
            Some(self.count)</span><span style="color:#dcdcdc;">
        } </span><span style="color:#569cd6;">else </span><span style="color:#dcdcdc;">{</span><span style="color:#dcdcdc;">
            None</span><span style="color:#dcdcdc;">
        }</span><span style="color:#dcdcdc;">
    }</span><span style="color:#dcdcdc;">
}	</span><span style="color:#dcdcdc;">
</span></code></pre>
<p>Here we have an object named <code>Counter</code>, which has been previously defined in a <code>struct</code>.  We are implementing the  <code>Iterator</code> trait on <code>Counter</code> which adds the <code>next</code> method.  Notice our implementation has it’s own instance variable?  This implementation is a closure that becomes “part” of the <code>Counter</code> object.  Just like objects in .NET are composed of closures, so are Rust objects as well.</p>
<p>However, traits are different from C# Extension Methods because they are part of the instance of the object thet they are attached to whereas Extension Methods are always static and you must pass the instance to them and they can only access the public members of the attached object.</p>

    </div>
</article>

</div>
</body>
</html>
